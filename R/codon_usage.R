#' Empirical codon usage indexes.
#'
#' This function computes empirical codon usage indexes based on either ribosome
#' P-sites, A-site or E-site frequencies associated to in-frame P-sites within
#' the coding sequence. It computes 64 codon usage indexes (one per triplet)
#' normalized for the frequency of the corresponding codons within the CDS and
#' generates a bar plot of the resulting values. Optionally, this function
#' compares the computed codon usage indexes with a set of 64 values provided by
#' the user. In this case the function returns a scatter plot, reporting the
#' result of a linear regression between the two variables (i.e. the two sets
#' of values) and the corresponding Pearson correlation coefficient.
#' 
#' @param data List of data tables from \code{\link{psite_info}}. Each data
#'   table may or may not include one or more columns among \emph{p_site_codon},
#'   \emph{a_site_codon} and \emph{e_site_codon} reporting the three nucleotides
#'   covered by the P-site, A-site and E-site, respectively. These columns can
#'   be previously generated by the \code{\link{psite_info}} function. Otherwise
#'   the column of interest can be specified by \code{site} and is automatically
#'   generated starting from a FASTA file or a BSgenome data package.
#' @param annotation Data table as generated by \code{\link{create_annotation}}.
#' @param sample Character string specifying the name of the sample of interest.
#' @param site Either "psite, "asite", "esite". It specifies if the empirical
#'   codon usage indexes should be based on ribosome P-sites ("psite"), A-sites
#'   ("asite") or E-sites ("esite"). Default is "psite".
#' @param fastapath Character string specifying the FASTA file used in the
#'   alignment step, including its path, name and extension. This file can
#'   contain reference nucleotide sequences either of a genome assembly or of
#'   all the transcripts (see \code{Details} and \code{fasta_genome}). Please
#'   make sure the sequences derive from the same release of the annotation file
#'   used in the \code{\link{create_annotation}} function. Note: either
#'   \code{fastapath} or \code{bsgenome} is required to compute the codon
#'   frequencies within the CDS used as normalization factors, even when
#'   \code{data} already includes one or more columns among \emph{p_site_codon},
#'   \emph{a_site_codon} and \emph{e_site_codon}. Default is NULL.
#' @param fasta_genome Logical value whether the FASTA file specified by
#'   \code{fastapath} contains nucleotide sequences of a genome assembly. If
#'   TRUE (the default), an annotation object is required (see \code{gtfpath}
#'   and \code{txdb}). FALSE implies the nucleotide sequences of all the
#'   transcripts is provided instead.
#' @param bsgenome Character string specifying the BSgenome data package with
#'   the genome sequences to be loaded. If not already present in the system, it
#'   is automatically installed through the biocLite.R script (check the list of
#'   available BSgenome data packages by the
#'   \code{\link[BSgenome]{available.genomes}} function of the BSgenome
#'   package). This parameter must be coupled with an annotation object (see
#'   \code{gtfpath} and \code{txdb}). Please make sure the sequences included in
#'   the specified BSgenome data pakage are in agreement with the sequences used
#'   in the alignment step. Note: either \code{fastapath} or \code{bsgenome} is
#'   required to compute the codon frequencies within the CDS used as
#'   normalization factors, even when \code{data} already includes one or more
#'   columns among \emph{p_site_codon}, \emph{a_site_codon} and
#'   \emph{e_site_codon}. Default is NULL.
#' @param gtfpath Character string specifying the location of a GTF file,
#'   including its path, name and extension. Please make sure the GTF file and
#'   the sequences specified by \code{fastapath} or \code{bsgenome} derive from
#'   the same release. Note that either \code{gtfpath} or \code{txdb} is
#'   required if and only if nucleotide sequences of a genome assembly are
#'   provided (see \code{fastapath} or \code{bsgenome}). Default is NULL.
#' @param txdb Character string specifying the TxDb annotation package to be
#'   loaded. If not already present in the system, it is automatically installed
#'   through the biocLite.R script (check
#'   \href{http://bioconductor.org/packages/release/BiocViews.html#___TxDb}{here}
#'    the list of available TxDb annotation packages). Please make sure the TxDb
#'   annotation package and the sequences specified by \code{fastapath} or
#'   \code{bsgenome} derive from the same release. Note that either
#'   \code{gtfpath} or \code{txdb} is required if and only if nucleotide
#'   sequences of a genome assembly are provided (see \code{fastapath} or
#'   \code{bsgenome}). Default is NULL.
#' @param dataSource Optional character string describing the origin of the GTF
#'   data file. This parameter is considered only if \code{gtfpath} is
#'   specified. For more information about this parameter please refer to the
#'   description of \emph{dataSource} of the
#'   \code{\link[GenomicFeatures]{makeTxDbFromGFF}} function included in the
#'   \code{GenomicFeatures} package.
#' @param organism Optional character string reporting the genus and species of
#'   the organism of the GTF data file. This parameter is considered only if
#'   \code{gtfpath} is specified. For more information about this parameter
#'   please refer to the description of \emph{organism} of the
#'   \code{\link[GenomicFeatures]{makeTxDbFromGFF}} function included in the
#'   \code{GenomicFeatures} package.
#' @param transcripts Character string vector listing the name of transcripts to
#'   be included in the analysis. Default is NULL i.e. all transcripts are used.
#'   Please note: transcripts without annotated CDS and transcripts whose coding
#'   sequence length is not divisible by 3 are automatically discarded.
#' @param codon_values Data table containing 64 codon-specific values. If
#'   specified, the provided values are compared with the empirical codon usage
#'   indexes computed for the sample of interest. The data table must contain
#'   the DNA or RNA nucleotide sequence of the 64 codons and the corresponding
#'   values arranged in two columns named \emph{codon} and \emph{value},
#'   respectively. Please note: a data table of the same format is returned by
#'   \code{\link{codon_usage_psite}} itself. Default is NULL.
#' @param scatter_label Logical value whether to label the dots of the scatter
#'   plot generated by specifying \code{codon_values}. Each dot is labeled using
#'   either the nucleotide sequence of the codon or the corresponding amino acid
#'   symbol (see \code{aminoacid}). This parameter is considered only if
#'   \code{codon_values} is specified. Default is FALSE.
#' @param aminoacid Logical value whether to use the amino acid symbols to label
#'   the dots of the scatter plot generated by specifying \code{codon_values}.
#'   Default is FALSE i.e. the nucleotide sequences of the codons are used
#'   instead. This parameter is considered only if \code{codon_values} is
#'   specified and \code{scatter_label} is TRUE. Default is FALSE.
#' @details \strong{riboWaltz} only works for read alignments based on
#'   transcript coordinates. This choice is due to the main purpose of RiboSeq
#'   assays to study translational events through the isolation and sequencing
#'   of ribosome protected fragments. Most reads from RiboSeq are supposed to
#'   map on mRNAs and not on introns and intergenic regions. Nevertheless, BAM
#'   based on transcript coordinates can be generated in two ways: i) aligning
#'   directly against transcript sequences; ii) aligning against standard
#'   chromosome sequences, requiring the outputs to be translated in transcript
#'   coordinates. The first option can be easily handled by many aligners (e.g.
#'   Bowtie), given a reference FASTA file where each sequence represents a
#'   transcript, from the beginning of the 5' UTR to the end of the 3' UTR. The
#'   second procedure is based on reference FASTA files where each sequence
#'   represents a chromosome, usually coupled with comprehensive gene annotation
#'   files (GTF or GFF). The STAR aligner, with its option --quantMode
#'   TranscriptomeSAM (see Chapter 6 of its
#'   \href{http://labshare.cshl.edu/shares/gingeraslab/www-data/dobin/STAR/STAR.posix/doc/STARmanual.pdf}{manual}),
#'    is an example of tool providing such a feature.
#' @return A list containing a ggplot2 object ("plot") and the data table with
#'   the associated data ("dt"). If \code{codon_values} is specified, an
#'   additional ggplot2 object ("plot_comparison") is returned.
#' @import data.table
#' @import ggplot2
#' @export
codon_usage_psite <- function(data, annotation, sample, site = "psite",
                              fastapath = NULL, fasta_genome = TRUE,
                              bsgenome = NULL, gtfpath = NULL, txdb = NULL, 
                              dataSource = NA, organism = NA, transcripts = NULL, 
                              codon_values = NULL, scatter_label = FALSE, 
                              aminoacid = FALSE) {
  
  if(site != "psite" & site != "asite" & site != "esite"){
    cat("\n")
    stop("parameter site must be either \"psite\", \"asite\" or \"esite\" \n\n")
  }
  
  if(length(codon_values) != 0){
    rownames(codon_values) <- as.character(codon_values$codon)
    if (nrow(codon_values) < 64 | length(unique(rownames(codon_values))) < 64){
      cat("\n")
      stop("number of different triplets in codon_values < 64. At least one codon is missing\n\n")
    } else {
      if (length(unique(rownames(codon_values))) > 64){
        cat("\n")
        stop("number of different triplets in codon_values > 64. Too many codons\n\n")
      }
    }
  }
  
  if(length(fastapath) == 0 & length(bsgenome) == 0){
    cat("\n")
    stop("impossible to normalize the data: no nucleotide sequences are provided. Either fastpath or bsgenome must be specified\n\n")
  }

  if(((length(fastapath) != 0 & (fasta_genome == TRUE | fasta_genome == T)) |
      length(bsgenome) != 0) &
     length(gtfpath) == 0 & length(txdb) == 0){
    cat("\n")
    stop("genome annotation file not specified (both GTF path and TxDb object are missing)\n\n")
  }
  
  if(length(fastapath) != 0 & length(bsgenome) != 0){
    cat("\n")
    warning("both fastapath and bsgenome are specified. Only fastapath will be considered\n")
    bsgenome = NULL
  }
  
  if(length(gtfpath) != 0 & length(txdb) != 0){
    cat("\n")
    warning("both gtfpath and txdb are specified. Only gtfpath will be considered\n")
    txdb = NULL
  }
  
  if((length(gtfpath) != 0 | length(txdb) != 0) &
     ((length(fastapath) == 0 & length(bsgenome) == 0) |
      (length(fastapath) != 0 & (fasta_genome == FALSE | fasta_genome == F)))){
    cat("\n")
    warning("a genome annotation file is specified but no sequences from genome assembly are provided\n")
  }
  
  if(length(gtfpath) != 0 | length(txdb) != 0){
    if(length(gtfpath) != 0){
      path_to_gtf <- gtfpath
      txdbanno <- GenomicFeatures::makeTxDbFromGFF(file=path_to_gtf, format="gtf", dataSource = dataSource, organism = organism)
    } else {
      if(txdb %in% rownames(installed.packages())){
        library(txdb, character.only = TRUE)
      } else {
        source("https://bioconductor.org/biocLite.R")
        biocLite(txdb, suppressUpdates = TRUE)
        library(txdb, character.only = TRUE)
      }
      txdbanno <- get(txdb)
    }
  }
  
  if(length(fastapath) != 0 | length(bsgenome) != 0){
    if(length(fastapath) != 0) {
      if(fasta_genome == TRUE | fasta_genome == T){
        temp_sequences <- Biostrings::readDNAStringSet(fastapath, format = "fasta", use.names = TRUE)
        names(temp_sequences) <- tstrsplit(names(temp_sequences), " ", fixed = TRUE, keep = 1)[[1]]
        exon <- suppressWarnings(GenomicFeatures::exonsBy(txdbanno, by="tx", use.names=TRUE))
        exon <- as.data.table(exon[unique(names(exon))])
        sub_exon_plus <- exon[as.character(seqnames) %in% names(temp_sequences) & strand == "+"]
        sub_exon_minus <- exon[as.character(seqnames) %in% names(temp_sequences) & strand == "-"
                               ][, new_end := width(temp_sequences[as.character(seqnames)]) - start + 1
                                 ][, new_start := width(temp_sequences[as.character(seqnames)]) - end + 1]
        
        seq_dt_plus <- sub_exon_plus[, nt_seq := "emp"
                                     ][, nt_seq := as.character(Biostrings::subseq(temp_sequences[as.character(seqnames)],
                                                                                   start = start,
                                                                                   end = end))
                                       ][, list(seq = paste(nt_seq, collapse = "")), by = group_name]
        
        revcompl_temp_sequences <- reverseComplement(temp_sequences)
        seq_dt_minus <- sub_exon_minus[, nt_seq := "emp"
                                       ][, nt_seq := as.character(Biostrings::subseq(revcompl_temp_sequences[as.character(seqnames)],
                                                                                     start = new_start,
                                                                                     end = new_end))
                                         ][, list(seq = paste(nt_seq, collapse = "")), by = group_name]
        
        sequences <- Biostrings::DNAStringSet(c(seq_dt_plus$seq, seq_dt_minus$seq))
        names(sequences) <- c(unique(sub_exon_plus$group_name), unique(sub_exon_minus$group_name))
      } else {
        sequences <- Biostrings::readDNAStringSet(fastapath, format = "fasta", use.names = TRUE)
      }
    } else {
      if(bsgenome %in% installed.genomes()){
        library(bsgenome, character.only = TRUE)
      } else {
        source("http://www.bioconductor.org/biocLite.R")
        biocLite(bsgenome, suppressUpdates = TRUE)
        library(bsgenome, character.only = TRUE)
      }
      sequences <- GenomicFeatures::extractTranscriptSeqs(get(bsgenome), txdbanno, use.names=T)
    }
  }
  
  if(site == "psite" & !("p_site_codon" %in% colnames(data[[sample]]))){
    data[[sample]] <- data[[sample]][, p_site_codon := as.character(Biostrings::subseq(sequences[as.character(data[[sample]]$transcript)],
                                                                                            start = data[[sample]]$psite,
                                                                                            end = data[[sample]]$psite + 2))]
  }
  if(site == "asite" & !("a_site_codon" %in% colnames(data[[sample]]))){
    data[[sample]] <- data[[sample]][, a_site_codon := as.character(Biostrings::subseq(sequences[as.character(data[[sample]]$transcript)],
                                                                                      start = data[[sample]]$psite + 3,
                                                                                      end = data[[sample]]$psite + 5))]
  }
  if(site == "esite" & !("e_site_codon" %in% colnames(data[[sample]]))){
    data[[sample]] <- data[[sample]][, e_site_codon := as.character(Biostrings::subseq(sequences[as.character(data[[sample]]$transcript)],
                                                                                      start = data[[sample]]$psite - 3,
                                                                                      end = data[[sample]]$psite - 1))]
  }
  
  l_transcripts <- as.character(annotation[l_cds > 0 & l_cds %% 3 == 0, transcript])
  
  cod_aa <- data.table(codon=c("GCC", "GCG", "GCU", "GCA", "AGA", "CGG", "AGG", "CGA", "CGC", "CGU", "AAC", "AAU", "GAC", "GAU", "UGC", "UGU", "CAA", "CAG", "GAG", "GAA", "GGC", "GGU", "GGA", "GGG", "CAC", "CAU", "AUA", "AUC", "AUU", "CUG", "CUA", "UUA", "CUU", "UUG", "CUC", "AAA", "AAG", "AUG", "UUC", "UUU", "CCG", "CCC", "CCU", "CCA", "AGC", "UCG", "UCU", "UCA", "UCC", "AGU", "UAG", "UAA", "UGA", "ACA", "ACC", "ACG", "ACU", "UGG", "UAU", "UAC", "GUA", "GUG", "GUU", "GUC"),
                       aa=c("A", "A", "A", "A", "R", "R", "R", "R", "R", "R", "N", "N", "D", "D", "C", "C", "Q", "Q", "E", "E", "G", "G", "G", "G", "H", "H", "I", "I", "I", "L", "L", "L", "L", "L", "L", "K", "K", "M", "F", "F", "P", "P", "P", "P", "S", "S", "S", "S", "S", "S", "*", "*", "*", "T", "T", "T", "T", "W", "Y", "Y", "V", "V", "V", "V"))
  cod_lev <- gsub("U", "T", cod_aa$codon)
  
  if (length(transcripts) == 0) {
    c_transcript <- l_transcripts
  } else {
    c_transcript <- intersect(l_transcripts, transcripts)
  }

  sub_sequences <- sequences[c_transcript]
  cds_biost <- Biostrings::subseq(sub_sequences,
                      start = annotation[transcript %in% names(sub_sequences), l_utr5] + 1,
                      end = annotation[transcript %in% names(sub_sequences), l_utr5] +
                        annotation[transcript %in% names(sub_sequences), l_cds])
  
  seq_freq <- (Biostrings::trinucleotideFrequency(cds_biost, step = 3,
                                                  as.prob = TRUE,
                                                  with.labels = TRUE,
                                                  simplify.as = "collapsed")) * 1000
  names(seq_freq) <- gsub("T", "U", names(seq_freq))
  
  dt <- data[[sample]][as.character(transcript) %in% c_transcript & psite_region == "cds" & psite_from_start %% 3 == 0]
  
  if(site == "psite"){
    norm_table <- data.table(table(factor(dt$p_site_codon, levels = cod_lev)))
  } else {
    if(site == "asite"){
      dt <- dt[psite_from_stop <= -3]
      norm_table <- data.table(table(factor(dt$a_site_codon, levels = cod_lev)))
    } else {
      dt <- dt[psite_from_start >= 3]
      norm_table <- data.table(table(factor(dt$e_site_codon, levels = cod_lev)))
    }
  }
  
  colnames(norm_table) <- c("codon", "count")
  norm_table[, codon := gsub("T", "U", codon)]
  norm_table[, count := (count / sum(count)) * 1000]

  norm_table <- norm_table[, class := "cds"
                           ][codon == "AUG", class := "start"
                             ][codon %in% c("UAA", "UGA", "UAG"), class := "stop"
                               ][, class := factor(class, levels = c("start", "cds", "stop"), labels=c("Start codon", "cds", "Stop codon"))
                                 ][cod_aa, on = "codon"
                                   ][, value := count / seq_freq[codon]
                                     ][, value := value - min(value)
                                       ][, value := value / max(value)
                                         ][order(value)
                                           ][, codon := factor(codon, levels = codon)]
  
  colour_codon <- ifelse(norm_table$codon == "AUG", "#104ec1",
                         ifelse(norm_table$codon %in% c("UAA", "UGA", "UAG"),
                                "darkred", "gray40"))

  bs <- 30
  bp <- ggplot(norm_table,aes(x = codon, y = value, fill = class)) +
    geom_bar(stat = "identity", alpha = 0.9) +
    scale_fill_manual(name = "", breaks=c("Start codon","Stop codon"), values = c("#104ec1", "gray60", "darkred")) +
    theme_bw(base_size = bs) +
    theme(legend.position = "top", legend.margin=margin(10,0,0,0), legend.box.margin=margin(-7,-5,-20,-5)) +
    theme(legend.text = element_text(margin = margin(l = -10, unit = "pt"))) +
    scale_x_discrete("Codon") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5, size = bs * 0.5)) +
    geom_text(aes(label = aa), vjust = -0.5, size = bs/6) +
    theme(axis.text.x = element_text(colour = colour_codon)) +
    scale_y_continuous("Usage index", limits = c(0,1.05), breaks = c(0,0.5,1))
  
  output <- list()
  output[["plot"]] <- bp
  output[["dt"]] <- norm_table[, c("codon", "class", "value",  "aa")]

  if(length(codon_values) != 0){
    codon_values <- codon_values[, list(codon, value)]
    setnames(codon_values, old = c("codon", "value"), new =  c("codon", "comp_values"))
    codon_values[, codon := gsub("T", "U", codon)]
    norm_table <- norm_table[codon_values, on = "codon"
                             ][, comp_values := comp_values - min(comp_values)
                               ][, comp_values := comp_values / max(comp_values)]
               
    correlation <- round(cor(norm_table$value, norm_table$comp_values), 3)
    
    bs <- 22.5
    pcomp <- ggplot(norm_table,aes(x = value, y = comp_values, colour = class)) +
      geom_smooth(method = "lm", se=T, color="gray80", fill="gray80", linetype = 1, formula = y ~ x, level = 0.99,  fullrange = TRUE) +
      geom_point(alpha = 0.9, size = bs * 0.14) +
      scale_colour_manual(name = "", breaks = c("Start codon","Stop codon"), values = c("#104ec1", "gray40", "darkred")) +
      theme_bw(base_size = bs) +
      theme(legend.position = "top", legend.margin=margin(10,0,0,0), legend.box.margin=margin(-7,-5,-20,-5)) +
      theme(legend.text = element_text(margin = margin(l = -10, unit = "pt"))) +
      scale_x_continuous("Codon usage index", limits = c(-0.3,1.3), breaks = c(0,0.25,0.5,0.75,1), expand = c(0,0)) +
      scale_y_continuous("Codon usage", limits = c(-0.3,1.3), breaks = c(0,0.25,0.5,0.75,1), expand = c(0,0)) +
      coord_cartesian(xlim = c(-0.05,1.05), ylim = c(-0.05,1.05)) +
      annotate("text", x = 1, y = 0, label = paste0("R=",correlation), vjust = -0.2, size = bs * 0.2, hjust = 1, color = "black")
    
    if (scatter_label == T || scatter_label == TRUE) {
      if (aminoacid == T || aminoacid == TRUE) {
        pcomp <- pcomp +
          ggrepel::geom_text_repel(aes(value, comp_values, label = as.character(aa)), show.legend = F)
      } else {
        pcomp <- pcomp +
          ggrepel::geom_text_repel(aes(value, comp_values, label = as.character(codon)), show.legend = F)
      }
    }
    
    output[["plot_comparison"]] <- pcomp
  }
  return(output)
}
