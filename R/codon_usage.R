#' Compute and plot the usage of the codons.
#' 
#' For a specified sample computes the empirical codon usage i.e. the frequency 
#' of in-frame P-sites along the coding sequence codon by codon, normalized for 
#' the frequency in sequences of each codon. This function also allows to
#' compare the empirical codon usage of the specified sample with a set of
#' values provided by the user.
#' 
#' @param data A list of data frames from \code{\link{psite_info}} that may or 
#'   may not include a column \emph{psite_codon}, reporting the nucleotide
#'   sequence of the P-sites. This column can be generated by running 
#'   \code{\link{psite_info}} specifying the \code{fastapath} option. If the 
#'   data frame of interest does not include a \emph{psite_codon} column, the 
#'   information about the nucleotide sequnce of the P-sites will be 
#'   automatically generated throughout the function starting from the FASTA 
#'   specified in \code{fastapath}.
#' @param annotation A data frame from \code{\link{create_annotation}}.
#' @param sample A character string vector specifying the name of the sample
#'   of interest.
#' @param fastapath A character string specifying the path to the FASTA file
#'   containing the nucleotide sequence of the transcripts. For each mRNA the
#'   the record description line must contain the transcript name as in the
#'   reference transcriptome and the sequence must derive from the same relase
#'   of the genome. Either \code{fastapath} or \code{bsgenome_dp} coulped with
#'   \code{txdb} must be specified if the data frame of interest does not
#'   already include a \emph{psite_codon} column (see \code{\link{psite_info}}).
#'   This arguments are used to extract for each read the three nucletotides
#'   covered by the identified P-sites.
#' @param bsgenome_dp A character string specifying the name of the BSgenome
#'   data package to be loaded. If the specified data package is not already
#'   present in your system, it will be installed through the biocLite.R script.
#'   Please check the data packages available in the Bioconductor repositories
#'   for your version of R/Bioconductor using the
#'   \code{\link[BSgenome]{available.genomes}} function from the BSgenome package.
#'   Either \code{fastapath} or \code{bsgenome_dp} coulped with
#'   \code{txdb} must be specified if the data frame of interest does not
#'   already include a \emph{psite_codon} column (see \code{\link{psite_info}}).
#'   This arguments are used to extract for each read the three nucletotides
#'   covered by the identified P-sites.
#' @param txdb A TxDb object storing transcript annotations.  It is considered
#'   only if \code{bsgenome_dp} is specified.
#' @param transcripts A character string vector specifying the name of the 
#'   transcripts to be considered in the analysis. By default this argument is 
#'   NULL, which implies all the transcripts in \code{data} will be used. Either
#'   transcripts with no annotated \emph{5' UTR}, \emph{CDS} and
#'   \emph{3'UTR} or mRNAs not labeled as protein coding will be removed.
#' @return A list containing a ggplot2 object (named "plot"), and a data frame
#'   ("df") with the associated data. An additional ggplot2 object
#'   ("plot_comparison") is returned if the parameter \code{codon_usage} is
#'   specified.
#' @param codon_usage A data frame containing codon usage values provided by the
#'   user. These values will be compared with the codon usage of the sample of
#'   interest. The data frame must contain at least the 64 codons and the
#'   corresponding codon usage values, arranged in two columns named
#'   \emph{codon} and \emph{usage_index}, respectively. A data frame including
#'   these information is returned by the \code{\link{codon_usage_psite}}
#'   function. Default is NULL, meaning that no comparisons will be performed.
#' @param scatter_label A logical value whether or not to label the point of the
#'   scatter plot based on \code{codon_usage}. It is possible to associate to 
#'   each point the triplet of nucleotides or the corresponding amino acid (see
#'   \code{aminoacid}). Default is FALSE.
#' @param aminoacid A logical value whether or not to label the point of the 
#'   scatter plot based on \code{codon_usage} using the amino acids 
#'   corresponding to the triplets. Default is FALSE, meaning that the codon
#'   sequences will be used instead. It is considered only if 
#'   \code{scatter_label} is TRUE.
#' @import ggplot2
#' @import GenomicFeatures
#' @import BSgenome
#' @export
codon_usage_psite <- function(data, annotation, sample, fastapath,
                              bsgenome_dp = NULL, txdb = NULL,
                              transcripts = NULL, codon_usage = NULL,
                              scatter_label = F, aminoacid = F) {
  rownames(annotation) <- as.character(annotation$transcript)
  l.transcripts <- rownames(annotation)[which(annotation$l_utr5 > 0 &
                                                annotation$l_cds >0 &
                                                annotation$l_cds %% 3 == 0 &
                                                annotation$l_utr3 > 0)]
  
  cu_level <- apply(expand.grid(one = c("A","C","G","U"), two = c("A","C","G","U"), three=c("A","C","G","U")),1,function(x) paste0(as.character(x), collapse = ""))
  cod_aa <- data.frame(codon=c("GCC", "GCG", "GCU", "GCA", "AGA", "CGG", "AGG", "CGA", "CGC", "CGU", "AAC", "AAU", "GAC", "GAU", "UGC", "UGU", "CAA", "CAG", "GAG", "GAA", "GGC", "GGU", "GGA", "GGG", "CAC", "CAU", "AUA", "AUC", "AUU", "CUG", "CUA", "UUA", "CUU", "UUG", "CUC", "AAA", "AAG", "AUG", "UUC", "UUU", "CCG", "CCC", "CCU", "CCA", "AGC", "UCG", "UCU", "UCA", "UCC", "AGU", "UAG", "UAA", "UGA", "ACA", "ACC", "ACG", "ACU", "UGG", "UAU", "UAC", "GUA", "GUG", "GUU", "GUC"),
                       aa=c("A", "A", "A", "A", "R", "R", "R", "R", "R", "R", "N", "N", "D", "D", "C", "C", "Q", "Q", "E", "E", "G", "G", "G", "G", "H", "H", "I", "I", "I", "L", "L", "L", "L", "L", "L", "K", "K", "M", "F", "F", "P", "P", "P", "P", "S", "S", "S", "S", "S", "S", "*", "*", "*", "T", "T", "T", "T", "W", "Y", "Y", "V", "V", "V", "V"))
  rownames(cod_aa) <- as.character(cod_aa$codon)
  cod_lev <- gsub("U", "T", cod_aa$codon)
  
  if (length(transcripts) == 0) {
    c.transcript <- l.transcripts
  } else {
    c.transcript <- intersect(l.transcripts, transcripts)
  }
  
  if(length(fastapath) != 0 & length(bsgenome_dp) != 0){
    warning("fastapath and bsgenome_dp are both specified. Only fastapath will be considered\n")
    bsgenome_dp = NULL
  }
  
  if(length(bsgenome_dp) != 0 & length(txdb) == 0){
    cat("\n")
    stop("\nERROR: txdb is not specified \n\n")
  }
  
  if(length(fastapath) != 0 | length(bsgenome_dp) != 0){
    if(length(fastapath) != 0) {
      cat("adding codon\n\n")
      sequences_biost <- Biostrings::readDNAStringSet(fastapath, format = "fasta", use.names = TRUE)
    } else {
      if(length(bsgenome_dp) != 0){
        if(bsgenome_dp %in% installed.genomes()){
          library(bsgenome_dp, character.only = TRUE)
        } else {
          source("http://www.bioconductor.org/biocLite.R")
          biocLite(bsgenome_dp, suppressUpdates = TRUE)
          library(bsgenome_dp, character.only = TRUE)
        }
      }
      sequences_biost <- extractTranscriptSeqs(get(bsgenome_dp), txdb, use.names=T)
    }
    df$psite_codon <- as.character(subseq(sequences_biost[as.character(df$transcript)],
                                          start = df$psite,
                                          end = df$psite + 2))
  }

  if(!is.element('psite_codon', colnames(data[[sample]]))) {
    data[[sample]]$psite_codon <- as.character(Biostrings::subseq(sequences_biost[as.character(data[[sample]]$transcript)],
                                                      start = data[[sample]]$psite,
                                                      end = data[[sample]]$psite + 2))
  }
  
  sub_sequences_biost <- sequences_biost[c.transcript]
  cds_biost <- Biostrings::subseq(sub_sequences_biost,
                      start = annotation[names(sub_sequences_biost), "l_utr5"] + 1,
                      end = annotation[names(sub_sequences_biost), "l_utr5"] +
                        annotation[names(sub_sequences_biost), "l_cds"])
  
  seq_freq <- (Biostrings::trinucleotideFrequency(cds_biost, step = 3,
                                                  as.prob = TRUE,
                                                  with.labels = TRUE,
                                                  simplify.as = "collapsed")) * 1000
  names(seq_freq) <- gsub("T", "U", names(seq_freq))
  
  df <- subset(data[[sample]], as.character(transcript) %in% c.transcript & psite_region == "cds" & psite_from_start %% 3 == 0)
  temp_table <- as.data.frame(table(factor(df$psite_codon, levels=cod_lev)))
  temp_table$Var1 <- gsub("T", "U", temp_table$Var1)
  norm.table <- temp_table[match(cu_level, temp_table$Var1),]
  colnames(norm.table) <- c("codon", "count")
  norm.table$count <- (norm.table$count / sum(norm.table$count)) * 1000

  norm.table$class <- "cds"
  norm.table[which(as.character(norm.table$codon) == "AUG") , "class"] <- "start"
  stop_cod <- c("UAA", "UGA", "UAG")
  norm.table[which(as.character(norm.table$codon) %in% stop_cod) , "class"] <- "stop"
  norm.table$class <- factor(norm.table$class, levels=c("start", "cds", "stop"), labels=c("Start codon ", "cds", "Stop codon"))
  
  norm.table$aa <- cod_aa[as.character(norm.table$codon),"aa"]
  norm.table$usage_index <- norm.table$count / seq_freq[as.character(norm.table$codon)]
  norm.table$usage_index <- norm.table$usage_index - min(norm.table$usage_index)
  norm.table$usage_index <- norm.table$usage_index / max(norm.table$usage_index)
  norm.table <- norm.table[order(norm.table$usage_index),]
  norm.table$codon <- factor(norm.table$codon, levels=norm.table$codon)
  colour_codon <- ifelse(norm.table$codon == "AUG", "#104ec1", ifelse(norm.table$codon %in% stop_cod, "darkred", "gray40"))

  bs <- 30
  bp <- ggplot(norm.table,aes(x = codon, y = usage_index, fill = class)) +
    geom_bar(stat = "identity", alpha = 0.9) +
    scale_fill_manual(name = "", breaks=c("Start codon ","Stop codon"), values = c("#104ec1", "gray60", "darkred")) +
    theme_bw(base_size = bs) +
    theme(legend.position = "top") +
    scale_x_discrete("Codon") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5, size=bs*0.5)) +
    geom_text(aes(label=aa), vjust=-0.5) +
    theme(axis.text.x=element_text(colour = colour_codon)) +
    scale_y_continuous("Usage index", limits=c(0,1.05), breaks=c(0,0.5,1))
  
  output <- list()
  output[["plot"]] <- bp
  output[["df"]] <- norm.table[, c("codon", "class", "usage_index",  "aa")]

  if(length(codon_usage) != 0){
    rownames(codon_usage) <- as.character(codon_usage$codon)
    if (nrow(codon_usage) < 64 | length(unique(rownames(codon_usage))) < 64){
      cat("\n")
      stop("\nERROR: number of different triplets in codon_usage != 64. At least one codon is missing\n\n")
    } else {
      if (length(unique(rownames(codon_usage))) > 64){
        cat("\n")
        stop("\nERROR: number of different triplets in codon_usage > 64. Too many codons\n\n")
      }
    }
    codon_usage$codon <- gsub("T", "U", cu$codon)
    norm.table$comp_values <- codon_usage[as.character(norm.table$codon), "usage_index"]
    norm.table$comp_values <- norm.table$comp_values - min(norm.table$comp_values)
    norm.table$comp_values <- norm.table$comp_values / max(norm.table$comp_values)
    
    correlation <- round(cor(norm.table$usage_index, norm.table$comp_values), 3)
    
    bs <- 30
    pcomp <- ggplot(norm.table,aes(x = usage_index, y = comp_values, colour = class)) +
      geom_smooth(method = "lm", se=T, color="gray80", fill="gray80", linetype = 1, formula = y ~ x, level = 0.99,  fullrange = TRUE) +
      geom_point(alpha = 0.9, size=bs*0.9) +
      ggrepel::geom_text_repel(aes(usage_index, comp_values, label = codon), show.legend = F) +
      scale_colour_manual(name = "", breaks=c("Start codon ","Stop codon"), values = c("#104ec1", "gray40", "darkred")) +
      theme_bw(base_size = bs) +
      theme(legend.position = "top") +
      scale_x_continuous("Codon usage index", limits=c(-0.3,1.3), breaks=c(0,0.25,0.5,0.75,1), expand=c(0,0)) +
      scale_y_continuous("Codon usage", limits=c(-0.3,1.3), breaks=c(0,0.25,0.5,0.75,1), expand=c(0,0)) +
      coord_cartesian(xlim=c(-0.05,1.05), ylim=c(-0.05,1.05)) +
      geom_text(aes(x=1, y=0), label = paste0("R=",correlation), vjust=-0.2, size = bs*0.2, hjust = 1, color = "black")
    pcomp
    
    if (scatter_label == T) {
      if (aminoacid == T) {
        pcomp <- pcomp +
          ggrepel::geom_text_repel(aes(usage_index, comp_values, label = as.character(aa)), show.legend = F)
      } else {
        pcomp <- pcomp +
          ggrepel::geom_text_repel(aes(usage_index, comp_values, label = as.character(codon)), show.legend = F)
      }
    }
    
    output[["plot_comparison"]] <- pcomp
  }
  return(output)
}









